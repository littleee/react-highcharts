import $ from 'jquery';
import _ from 'lodash';
import cx from 'classnames';
import React, { Component } from 'react';
import EmptyDataTip from '../empty-data-tip/index.js';

let summary = function (array) {
  let result = 0;

  for (let i = 0; i < array.length; i++) {
    result += parseInt(array[ i ], 10);
  }

  return result;
};

const defaultColSetting = {
  key: null,
  title: null,
  width: null,
  sortable: true,
  sortfetch: true,
  template: null,
  format: (v) => v,
  render: (fmtVal, rowData, rowInd, colInd, rows) => fmtVal
};

const normalizeWidth = (width, fullWidth) => {
  if (width === undefined) {
    return 'auto';
  }

  if (typeof width === 'number') {
    return `${width}px`;
  }

  return width;
};

export default class Table extends Component {
  static defaultProps = {
    data: [],
    showCols: true,
    viewOptions: {
      helpers: {}
    },
    className: null,
    columns: [
      {
        key: 1,
        sortable: true,
        title: '数据列一',
        width: 20
      },
      {
        key: 2,
        sortable: true,
        title: '数据列二',
        width: 20
      },
      {
        key: 3,
        sortable: true,
        title: '数据列三',
        width: 20
      }
    ],
    defaultSortKey: undefined,
    sortKey: null,
    filterFn: (row) => true,
    isSelected: false,
    getSelections: (v) => v,
    isRadio: true,
    selectedRows: [],
    sortFetchKey: null,
    getSortKey: (v) => v,
    tbodyClassName: null
  };

  constructor(props, context) {
    super(props, context);

    let sortKey = props.defaultSortKey || props.sortKey || null;

    this.state = {
      sortKey,
      selectedRows: props.selectedRows || [],
      sortAscending: props.sortAscending || 1,
      sortFetchKey: props.sortFetchKey || null,
      data: this.props.data || [],
      limit: 0,
      colgroups: new Array(props.columns.length)
    };

    this.ths      = [];
    this.pageX    = null;   // 拖拽前的鼠标位置
    this.target   = null;   // 记录当前操作的元素
    this.$width   = null;   // 存储表格宽度
    this.dragged  = false;  // 是否已经开始拖拽
    this.scaledWidth = new Array(props.columns.length);
    this.minWidth = 0;

    this.handleMouseDown = this.handleMouseDown.bind(this);
    this.handleMouseMove = this.handleMouseMove.bind(this);
  }

  syncScrollWidth2State() {
    /**
     * 说明：以下逻辑是为了处理表头固定，
     * 表内容超出高度后出现滚动条，
     * 而表头内容区域发生偏移的情况。
     *
     * |-----------------------------------|---|
     * | key | key | key | key | key | key |   |
     * |-----------------------------------|---|
     * | val | val | val | val | val | val | ↑ |
     * |-----------------------------------|   |
     * | val | val | val | val | val | val |   |
     * |-----------------------------------|   |
     * | val | val | val | val | val | val |   |
     * |-----------------------------------|   |
     * | val | val | val | val | val | val |   |
     * |-----------------------------------|   |
     * | val | val | val | val | val | val | ↓ |
     * |-----------------------------------|---|
     */
    let table = this.refs.table,
        tbody = this.refs.tbody,
        thead = this.refs.thead,
        limit = $(tbody).width() - $(table).width();

    if (limit > 0) {
      $(thead).css({
        'padding-right': limit
      });

      this.setState({limit});
    }
  }

  sortDataByKey() {
    if (this.state.sortKey) {
      if (this.state.sortAscending > 0) {
        this.state.data = _.sortBy(this.state.data, (i) => i[this.state.sortKey], this);
      } else {
        this.state.data = _.sortBy(this.state.data, (i) => i[this.state.sortKey], this).reverse();
      }

      this.forceUpdate();
    }
  }

  trans2FixedWidth(width) {
    let precent = parseFloat(width) / 100;
    return Math.floor(this.$width * precent);
  }

  componentDidMount() {
    let { scaledWidth } = this,
        { colgroups } = this.state,
        $th = $(this.ths[0]);

    this.syncScrollWidth2State();
    this.sortDataByKey();

    this.$width = this.refs.table.clientWidth;

    this.minWidth = parseInt($th.css('minWidth'), 10);

    _.fill(scaledWidth, this.minWidth);

    this.props.columns.forEach(({width}, key) => {
      if (this.isPercentWidth(width)) {
        width = this.trans2FixedWidth(width);

        scaledWidth[ key ] = width;
        colgroups[   key ] = width;
      }
    });
  }

  componentDidUpdate() {
    if (this.state.limit === 0) {
      this.syncScrollWidth2State();
    }
  }

  componentWillReceiveProps(nextProps) {
    let { sortKey } = this.state;

    sortKey = nextProps.defaultSortKey || nextProps.sortKey || sortKey;

    this.setState({
      sortKey,
      data: nextProps.data,
      columns: nextProps.columns
    }, this.sortDataByKey);
  }

  rowClick(row, index) {
    const isSelected = this.props.isSelected;

    if (isSelected) {
      if (this.props.isRadio) {
        this.state.selectedRows = [ row ];
      } else {
        if (! _.find(this.state.selectedRows, row)) {
          this.state.selectedRows.push(row);
        } else {
          this.state.selectedRows = _.filter(this.state.selectedRows, (r) => {
            return ! _.isEqual(r, row);
          });
        }
      }

      this.props.getSelections(this.state.selectedRows);
      this.forceUpdate();
    }

    if (_.isFunction(this.props.rowClick)) {
      this.props.rowClick(row, index);
    }
  }

  handleSort(key) {
    if ( this.dragged === true) {
      return this.stopScaleWidth();
    }

    this.setState({
      sortAscending: this.state.sortAscending * (-1),
      sortKey: key
    });

    this.state.data = _.sortBy(this.state.data, function(i) {
      return i[key];
    }, this);

    if (this.state.sortAscending > 0) {
      this.state.data.reverse();
    }

    let { onChangeSortKey } = this.props;

    if (_.isFunction(onChangeSortKey)) onChangeSortKey(key);

    this.forceUpdate();
  }

  handleSortFetch(key) {
    if ( this.dragged === true) {
      return this.stopScaleWidth();
    }

    if (this.state.sortFetchKey === key) {
      this.props.getSortKey(`-${key}`);
    } else {
      this.props.getSortKey(key);
    }

    this.setState({
      sortFetchKey: key
    });
  }

  renderRow(row, rowInd, rows) {
    if ( this.props.filterFn(row) ) {

    }
    return this.props.filterFn(row) ? (
      <tr key={rowInd} onClick={ this.rowClick.bind(this, row, rowInd) } className={ _.find(this.state.selectedRows, row) ? 'active' : null }>
        {
          this.props.columns.map((col, colInd) => {
            return (
              <td key={col.key} {...col.attrs} className={ cx({
                'text-truncate': col.ellipsis
              }) }>
                {
                  this.renderCell(col, row, rowInd, colInd, rows)
                }
              </td>
            )
          })
        }
      </tr>
    ) : null;
  }

  renderCell(colSetting, rowData, rowInd, colInd, rows) {
    var value = rowData[colSetting['key']];
    var formatFn;

    if (colSetting.format) {
      if (typeof colSetting.format === 'string') {
        formatFn = this.props.viewOptions.helpers.format[colSetting.format];
      } else {
        formatFn = colSetting.format;
      }
    }

    if ( ! formatFn) {
      formatFn = defaultColSetting.format;
    }

    var fmtVal = formatFn(value);

    if (colSetting.template) {
      return (
        <div dangerouslySetInnerHTML={{
          __html: _.template(colSetting.template)({
            fmtVal: fmtVal,
            rowData: rowData,
            rowInd: rowInd,
            colInd: colInd,
            rows: rows,
            format: this.props.viewOptions.helpers.format
          })
        }} />
      )
    } else if (colSetting.render) {
      return (
        colSetting.render(fmtVal, rowData, rowInd, colInd, rows, this)
      );
    }

    return fmtVal;
  }

  getThContent(column, isLast) {
    let content = [
      <span key="title" className="col-title">{ column.title }</span>,
      column.sortable ? (
        <span key={`${column.key}down`} className={cx({
          'icon sort-icon': true,
          'd-hide': column.key !== this.state.sortKey,
          'icon-up': this.state.sortAscending === 1,
          'icon-down': this.state.sortAscending === -1
        })}></span>
      ) : null
    ];

    let style = {
      right: -this.state.limit
    };

    return this.state.limit > 0 && isLast ? <div className="table-limit" style={style}>{ content }</div> : content;
  }

  getValue(element, property) {
    let $element = element instanceof $ ? element : $(element);

    return parseInt($element.css(property), 10);
  }

  /**
   * 处理表头列开始拖拽.
   *
   * @param  {Object} event
   * @param  {Object} target
   * @return {Undefined}
   */
  handleMouseDown({nativeEvent: event, target}) {
    if (target.tagName !== 'TH') { // 如果不是 th，则往上找一次
      target = target.parentNode;
    }

    let $target = $(target);

    if (event.offsetX > target.offsetWidth - 10) {
      this.pageX     = event.pageX;
      this.target    = target;
      this.dragged   = true;
      this.oldWidth  = target.offsetWidth;

      let currentIndex = $target.index(),
          colgroups = [],
          stateColgroups = this.state.colgroups,
          { scaledWidth } = this;

      _.each(this.ths, (element, index) => {
        let width,
            $element = $(element),
            borderLeftWidth  = this.getValue($element, 'borderLeftWidth'),
            borderRightWidth = this.getValue($element, 'borderRightWidth'),
            fullWidth = element.clientWidth + borderLeftWidth + borderRightWidth;

        if ( _.isUndefined(stateColgroups[ index ]) ) {
          if ( index < currentIndex ) {
            this.scaledWidth[ index ] = fullWidth;
          }

          width = index < currentIndex ? fullWidth : 'auto';
        } else {
          width = stateColgroups[ index ];
        }

        if (index < currentIndex) {
          scaledWidth[ index ] = fullWidth;
        }

        colgroups.push( width );
      });

      this.setState({ colgroups });

      $(document).on('mousemove', this.handleMouseMove);
      $(document).on('mouseup', this.handleMouseUp);
    }
  }

  /**
   * 处理表头列样式.
   * 鼠标在表头列中移动，当鼠标置于末端时应显示为可拖拽的样式，提醒用于该列是可拖拽改变列宽度的。
   *
   * @param  {Object} event
   * @param  {Object} target
   * @return {Undefined}
   */
  handleThMouseMove({nativeEvent: event, target}) {
    if (target.nodeName !== 'TH') return;

    let cursor = 'default';

    if (this.dragged === true) {
      cursor = 'col-resize';
    } else {
      cursor = event.offsetX > target.offsetWidth - 10 ? 'col-resize' : 'default';
    }

    target.style.cursor = cursor;
  }

  /**
   * 开始拖拽表头列缩放宽度.
   *
   * @param  {Number} pageX
   * @return {Undefined}
   */
  handleMouseMove({pageX}) {
    let $target  = $(this.target),
        width    = this.target.clientWidth;

    if ( this.dragged === true ) {
      document.body.style.cursor = 'col-resize';

      if (this.oldWidth + (pageX - this.pageX) > 0) {
        width = this.oldWidth + pageX - this.pageX; // 计算拖拽的宽度
      }

      let colgroups = [],
          { colgroups: stateColgroups } = this.state,
          currentIndex = $target.index();

      if (width < this.minWidth) width = this.minWidth; // 当前拖拽元素的宽度不能小于最小宽度

      _.each(this.ths, (element, index) => {
        let _width = stateColgroups[index],
            borderLeftWidth  = this.getValue(element, 'borderLeftWidth'),
            borderRightWidth = this.getValue(element, 'borderRightWidth'),
            fullWidth = element.clientWidth + borderLeftWidth + borderRightWidth;

        if (index < currentIndex) {
          _width = fullWidth;
        } else if (index === currentIndex) {
          _width = width;
        } else {
          if (fullWidth < this.minWidth) {
            _width = this.minWidth;
          }
        }

        _width = _width < this.minWidth ? this.minWidth : _width;

        colgroups.push( _width ); // 其他元素的宽度不能小于最小宽度
      });

      let scaledWidth = [ // 存储已经拖拽过的列宽度，如果没有拖拽过的列，则为最小宽度，用于限制总宽度（所有列宽总和不得大于表格宽度）。
        ...this.scaledWidth.slice(0, currentIndex),
        width,
        ...this.scaledWidth.slice(currentIndex + 1)
      ],
      isOverflow = this.$width - summary(scaledWidth) < 0;

      if (
        isOverflow &&
        pageX > this.pageX
      ) {
        return;
      }

      this.target.style.width = `${ width }px`;

      this.scaledWidth = scaledWidth;

      this.setState({ colgroups });
    }
  }

  /**
   * 结束拖拽.
   *
   * @param  {Number} pageX
   * @return {Undefined}
   */
  handleMouseUp({pageX}) {
    document.body.style.cursor = 'default';

    if (pageX === this.pageX) {
      this.stopScaleWidth(); // 如果位置一样，则表示是点击事件（排序）
    }

    $(document).off('mousemove', this.handleMouseMove);
    $(document).off('mouseup', this.handleMouseMove);
  }

  /**
   * 鼠标移出后还原鼠标样式.
   *
   * @param  {Object} options.target
   * @return {Undefined}
   */
  handleMouseOut({target}) {
    target.style.cursor = 'default';
  }

  /**
   * 结束拖拽.
   * 之所以将其封装成方法，是用于解决拖拽完成后又排序的问题，正常逻辑应该是只缩放不排序。
   *
   * @return {Undefined}
   */
  stopScaleWidth() {
    this.target   = null;
    this.dragged  = false;
    this.pageX    = null;
  }

  isPercentWidth(width) {
    return /%$/.test(width);
  }

  renderColElement({key, width, scaleable}, index) {
    let { colgroups } = this.state,
        { scaledWidth } = this,
        isPrecent = this.isPercentWidth(width);

    if ( _.isUndefined(width) ) {
      width = colgroups[ index ];
    } else {
      if ( isPrecent ) {
        if (scaleable === true) {
          if (colgroups[ index ]) {
            width = colgroups[ index ] || 'auto';
          } else {
            colgroups[ index ] = width;
          }
        }
      } else {
        width = parseInt(width, 10);

        colgroups[   index ] = width;
        scaledWidth[ index ] = width;
      }
    }

    return (
      <col
        key={ key }
        style={{
          width: normalizeWidth(width)
        }}
      />
    );
  }

  renderError() {

  }

  render() {
    this.ths = [];

    let { columns, showCols, tbodyClassName, className } = this.props;

    return (
      <div className={ cx('table-root', className) } style={{
        minWidth: this.$width,
        minHeight: 10
      }}>
        {
          showCols ? (
            <div className="table-header" ref="thead">
              <table className="table table-fixed">
                <colgroup>
                {
                  columns.map(this.renderColElement.bind(this))
                }
                </colgroup>
                <thead>
                  <tr>
                  {
                    columns.map((col, colInd) => {
                      let isLast = colInd === columns.length - 1,
                          events = null;

                      if (col.scaleable === true) {
                        events = {
                          onMouseDown: this.handleMouseDown.bind(this),
                          onMouseMove: this.handleThMouseMove.bind(this),
                          onMouseUp: this.handleMouseUp.bind(this),
                          onMouseOut: this.handleMouseOut.bind(this)
                        };
                      }

                      return (
                        <th
                          ref={ th => th && this.ths.push(th) }
                          key={col.key}
                          style={{
                            width: col.scaleable ? this.state.colgroups[ colInd ] : col.width
                          }}
                          className={ cx({
                            'text-truncate': col.ellipsis,
                            'unselect': col.scaleable,
                            'relative': isLast && this.state.limit > 0
                          }) }
                          onClick={ col.sortable ? this.handleSort.bind(this, col.key) : (col.sortfetch ? this.handleSortFetch.bind(this, col.key) : null) }
                          {...events}
                        >
                          <div className={cx({
                            'sortable': col.sortable || col.sortfetch
                          })}>
                            { this.getThContent(col, isLast) }
                          </div>
                        </th>
                      )
                    })
                  }
                  </tr>
                </thead>
              </table>
            </div>
          ) : null
        }
        <div className={ cx('table-body', tbodyClassName) } ref="tbody">
          <table className="table table-fixed table-striped table-hover" ref="table">
            <colgroup>
            {
              columns.map(this.renderColElement.bind(this))
            }
            </colgroup>
            <tbody>
            {
              this.props.error ? (
                this.renderError()
              ) : (
                this.state.data.length > 0 ? (
                  this.state.data.map((row, rowInd, rows) => {
                    return this.renderRow(row, rowInd, rows);
                  })
                ) : (
                  <tr>
                    <td colSpan={ columns.length }>
                      <EmptyDataTip />
                    </td>
                  </tr>
                )
              )
            }
            </tbody>
          </table>
        </div>
      </div>
    )
  }
}
