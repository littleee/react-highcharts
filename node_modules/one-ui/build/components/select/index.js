'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _jquery = require('jquery');

var _jquery2 = _interopRequireDefault(_jquery);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var sizerStyle = {
  position: 'absolute',
  visibility: 'hidden',
  height: 0,
  width: 0,
  overflow: 'scroll',
  whiteSpace: 'nowrap'
};

var Input = function (_React$Component) {
  _inherits(Input, _React$Component);

  function Input(props) {
    _classCallCheck(this, Input);

    var _this = _possibleConstructorReturn(this, (Input.__proto__ || Object.getPrototypeOf(Input)).call(this, props));

    _this.state = {
      inputWidth: props.minWidth
    };
    return _this;
  }

  _createClass(Input, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.copyInputStyles();
      this.updateInputWidth();
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      this.updateInputWidth();
    }
  }, {
    key: 'copyInputStyles',
    value: function copyInputStyles() {
      if (!window.getComputedStyle) {
        return;
      }

      var inputStyle = window.getComputedStyle(_reactDom2.default.findDOMNode(this.refs.input));
      var widthNode = _reactDom2.default.findDOMNode(this.refs.sizer);

      widthNode.style.fontSize = inputStyle.fontSize;
      widthNode.style.fontFamily = inputStyle.fontFamily;

      if (this.props.placeholder) {
        var placeholderNode = _reactDom2.default.findDOMNode(this.refs.placeholderSizer);
        placeholderNode.style.fontSize = inputStyle.fontSize;
        placeholderNode.style.fontFamily = inputStyle.fontFamily;
      }
    }
  }, {
    key: 'updateInputWidth',
    value: function updateInputWidth() {
      var $sizer = this.refs.sizer;
      if (typeof $sizer.scrollWidth === 'undefined') {
        return;
      }

      var newInputWidth;
      if (this.props.placeholder) {
        newInputWidth = Math.max($sizer.scrollWidth, this.refs.placeholderSizer.scrollWidth) + 2;
      } else {
        newInputWidth = $sizer.scrollWidth + 2;
      }

      if (newInputWidth < this.props.minWidth) {
        newInputWidth = this.props.minWidth;
      }

      if (newInputWidth !== this.state.inputWidth) {
        this.setState({
          inputWidth: newInputWidth
        });
      }
    }
  }, {
    key: 'focus',
    value: function focus() {
      this.refs.input.focus();
    }
  }, {
    key: 'select',
    value: function select() {
      this.refs.input.select();
    }
  }, {
    key: 'render',
    value: function render() {
      var nbspValue = (this.props.value || '').replace(/ /g, '&nbsp;');
      var wrapperStyle = this.props.style || {};

      var inputStyle = this.props.inputStyle || {};
      inputStyle.width = this.state.inputWidth;

      var placeholder = this.props.placeholder ? _react2.default.createElement(
        'div',
        { ref: 'placeholderSizer', style: sizerStyle },
        this.props.placeholder
      ) : null;

      return _react2.default.createElement(
        'div',
        { className: this.props.className, style: wrapperStyle },
        _react2.default.createElement('input', _extends({}, _lodash2.default.omit(this.props, 'minWidth'), { ref: 'input', className: this.props.inputClassName, style: inputStyle })),
        _react2.default.createElement('div', { ref: 'sizer', style: sizerStyle, dangerouslySetInnerHTML: { __html: nbspValue } }),
        placeholder
      );
    }
  }]);

  return Input;
}(_react2.default.Component);

Input.propTypes = {
  value: _propTypes2.default.any, // field value
  defaultValue: _propTypes2.default.any, // default field value
  onChange: _propTypes2.default.func, // onChange handler: function(newValue) {}
  style: _propTypes2.default.object, // css styles for the outer element
  className: _propTypes2.default.string, // className for the outer element
  minWidth: _propTypes2.default.oneOfType([// minimum width for input element
  _propTypes2.default.number, _propTypes2.default.string]),
  inputStyle: _propTypes2.default.object, // css styles for the input element
  inputClassName: _propTypes2.default.string // className for the input element
};

Input.defaultProps = {
  minWidth: 1
};

var stopPropagation = function stopPropagation(ev) {
  ev.stopPropagation();
};

var Option = function (_React$Component2) {
  _inherits(Option, _React$Component2);

  function Option() {
    _classCallCheck(this, Option);

    return _possibleConstructorReturn(this, (Option.__proto__ || Object.getPrototypeOf(Option)).apply(this, arguments));
  }

  _createClass(Option, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'select-item' },
        _react2.default.createElement(
          'span',
          { className: 'select-item-label' },
          this.props.label
        ),
        _react2.default.createElement(
          'span',
          { className: 'select-item-icon',
            onMouseDown: stopPropagation,
            onClick: this.props.onRemove,
            onTouchEnd: this.props.onRemove
          },
          '\xD7'
        )
      );
    }
  }]);

  return Option;
}(_react2.default.Component);

Option.propTypes = {
  label: _propTypes2.default.any.isRequired
};

var Select = function (_React$Component3) {
  _inherits(Select, _React$Component3);

  function Select(props) {
    _classCallCheck(this, Select);

    var _this3 = _possibleConstructorReturn(this, (Select.__proto__ || Object.getPrototypeOf(Select)).call(this, props));

    _this3.state = {
      options: props.options,
      isFocused: false,
      isOpen: false,
      isLoading: false
    };
    _this3._closeMenu = _this3._closeMenu.bind(_this3);
    _this3.handleMouseDown = _this3.handleMouseDown.bind(_this3);
    _this3.handleInputBlur = _this3.handleInputBlur.bind(_this3);
    _this3.handleInputFocus = _this3.handleInputFocus.bind(_this3);
    _this3.handleKeyDown = _this3.handleKeyDown.bind(_this3);
    _this3.handleInputChange = _this3.handleInputChange.bind(_this3);
    _this3.clearValue = _this3.clearValue.bind(_this3);
    return _this3;
  }

  _createClass(Select, [{
    key: '_closeMenu',
    value: function _closeMenu(e) {
      var el = e.target,
          container = this.refs.wrapper;
      if (this.state.isOpen && !_jquery2.default.contains(container, el)) {
        this.setState({
          isOpen: false
        });
      }
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this._optionsCache = {};
      this._optionsFilterString = '';
      this.setState(this.getStateFromValue(this.props.value));
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      (0, _jquery2.default)('body').on('click', this._closeMenu);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(newProps) {
      if (JSON.stringify(newProps.options) !== JSON.stringify(this.props.options)) {
        this.setState({
          options: newProps.options,
          filteredOptions: this.filterOptions(newProps.options)
        });
      }

      if (newProps.value !== this.state.value) {
        this.setState(this.getStateFromValue(newProps.value, newProps.options));
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      var self = this;
      if (!this.props.disabled && this._focusAfterUpdate) {
        clearTimeout(this._blurTimeout);

        this._focusTimeout = setTimeout(function () {
          self.getInputNode().focus();
          self._focusAfterUpdate = false;
        }, 50);
      }

      if (this._focusedOptionReveal) {
        if (this.refs.focused && this.refs.menu) {
          var focusedDOM = _reactDom2.default.findDOMNode(this.refs.focused);
          var menuDOM = _reactDom2.default.findDOMNode(this.refs.menu);
          var focusedRect = focusedDOM.getBoundingClientRect();
          var menuRect = menuDOM.getBoundingClientRect();

          if (focusedRect.bottom > menuRect.bottom || focusedRect.top < menuRect.top) {
            menuDOM.scrollTop = focusedDOM.offsetTop + focusedDOM.clientHeight - menuDOM.offsetHeight;
          }
        }

        this._focusedOptionReveal = false;
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      clearTimeout(this._blurTimeout);
      clearTimeout(this._focusTimeout);
      (0, _jquery2.default)('body').off('click', this._closeMenu);
    }
  }, {
    key: 'focus',
    value: function focus() {
      this.getInputNode().focus();
    }
  }, {
    key: 'getStateFromValue',
    value: function getStateFromValue(value, options) {
      var copyOptions = options;

      if (!options) {
        copyOptions = this.state.options;
      }

      // reset internal filter string
      this._optionsFilterString = '';

      var values = this.initValuesArray(value, copyOptions),
          filteredOptions = this.filterOptions(copyOptions, values);

      return {
        value: values.map(function (v) {
          return v.value;
        }).join(this.props.delimiter),
        values: values,
        inputValue: '',
        filteredOptions: filteredOptions,
        placeholder: !this.props.multi && values.length ? values[0].label : this.props.placeholder,
        focusedOption: !this.props.multi && values.length ? values[0] : filteredOptions[0]
      };
    }
  }, {
    key: 'initValuesArray',
    value: function initValuesArray(values, options) {
      var copyValues = values;

      if (!_lodash2.default.isArray(values)) {
        if (typeof values === 'string') {
          copyValues = values.split(this.props.delimiter);
        } else {
          copyValues = values ? [values] : [];
        }
      }

      return copyValues.map(function (val) {
        if (typeof val === 'string') {
          for (var key in options) {
            if (_lodash2.default.has(options, key) && options[key] && options[key].value === val) {
              return options[key];
            }
          }
          return { value: val, label: val };
        } else {
          return val;
        }
      });
    }
  }, {
    key: 'setValue',
    value: function setValue(value, focusAfterUpdate) {
      if (focusAfterUpdate || focusAfterUpdate === undefined) {
        this._focusAfterUpdate = true;
      }

      var newState = this.getStateFromValue(value);
      newState.isOpen = false;

      this.fireChangeEvent(newState);
      this.setState(newState);
    }
  }, {
    key: 'selectValue',
    value: function selectValue(value) {
      if (!this.props.multi) {
        this.setValue(value);
      } else if (value) {
        this.addValue(value);
      }
      // this._unbindCloseMenuIfClickedOutside();
    }
  }, {
    key: 'addValue',
    value: function addValue(value) {
      this.setValue(this.state.values.concat(value));
    }
  }, {
    key: 'popValue',
    value: function popValue() {
      this.setValue(this.state.values.slice(0, this.state.values.length - 1));
    }
  }, {
    key: 'removeValue',
    value: function removeValue(valueToRemove) {
      if (this.props.disabled) return;

      this.setValue(this.state.values.filter(function (value) {
        return value !== valueToRemove;
      }));
    }
  }, {
    key: 'clearValue',
    value: function clearValue(event) {
      // if the event was triggered by a mousedown and not the primary
      // button, ignore it.
      if (event && event.type === 'mousedown' && event.button !== 0) {
        return;
      }

      this.setValue(null);
    }
  }, {
    key: 'resetValue',
    value: function resetValue() {
      this.setValue(this.state.value === '' ? null : this.state.value);
    }
  }, {
    key: 'getInputNode',
    value: function getInputNode() {
      var input = this.refs.input;
      return this.props.searchable ? input : _reactDom2.default.findDOMNode(input);
    }
  }, {
    key: 'fireChangeEvent',
    value: function fireChangeEvent(newState) {
      if (newState.values[0] !== this.state.values[0] && this.props.onChange) {
        this.props.onChange(this.props.multi ? newState.values : newState.values[0]);
      }
    }
  }, {
    key: 'handleMouseDown',
    value: function handleMouseDown(event) {
      // if the event was triggered by a mousedown and not the primary
      // button, or if the component is disabled, ignore it.
      if (this.props.disabled || event.type === 'mousedown' && event.button !== 0) {
        return;
      }

      event.stopPropagation();
      event.preventDefault();

      if (this.state.isFocused) {
        this.setState({
          isOpen: true
        }, this._bindCloseMenuIfClickedOutside);
      } else {
        this._openAfterFocus = true;
        this.getInputNode().focus();
      }
    }
  }, {
    key: 'handleInputFocus',
    value: function handleInputFocus(event) {
      var newIsOpen = this.state.isOpen || this._openAfterFocus;
      this.setState({
        isFocused: true,
        isOpen: newIsOpen
      });
      this._openAfterFocus = false;

      if (this.props.onFocus) {
        this.props.onFocus(event);
      }
    }
  }, {
    key: 'handleInputBlur',
    value: function handleInputBlur(event) {
      var _this4 = this;

      this._blurTimeout = setTimeout(function () {
        if (_this4._focusAfterUpdate) {
          return;
        }

        _this4.setState({
          isFocused: false
        });
      }, 50);

      if (this.props.onBlur) {
        this.props.onBlur(event);
      }
    }
  }, {
    key: 'handleKeyDown',
    value: function handleKeyDown(event) {
      if (this.state.disabled) {
        return;
      }

      switch (event.keyCode) {
        case 8:
          // backspace
          if (!this.state.inputValue) {
            this.popValue();
          }
          return;

        case 9:
          // tab
          if (event.shiftKey || !this.state.isOpen || !this.state.focusedOption) {
            return;
          }
          this.selectFocusedOption();
          break;

        case 13:
          // enter
          this.selectFocusedOption();
          break;

        case 27:
          // escape
          if (this.state.isOpen) {
            this.resetValue();
          } else {
            this.clearValue();
          }
          break;

        case 38:
          // up
          this.focusPreviousOption();
          break;

        case 40:
          // down
          this.focusNextOption();
          break;
        default:
          return;
      }

      event.preventDefault();
    }

    // Ensures that the currently focused option is available in filteredOptions.
    // If not, returns the first available option.

  }, {
    key: '_getNewFocusedOption',
    value: function _getNewFocusedOption(filteredOptions) {
      for (var key in filteredOptions) {
        if (_lodash2.default.has(filteredOptions, key) && filteredOptions[key] === this.state.focusedOption) {
          return filteredOptions[key];
        }
      }

      return filteredOptions[0];
    }
  }, {
    key: 'handleInputChange',
    value: function handleInputChange(event) {
      // assign an internal variable because we need to use
      // the latest value before setState() has completed.
      this._optionsFilterString = event.target.value;

      if (this.props.asyncOptions) {
        this.setState({
          isLoading: true,
          inputValue: event.target.value
        });
      } else {
        var filteredOptions = this.filterOptions(this.state.options);
        this.setState({
          isOpen: true,
          inputValue: event.target.value,
          filteredOptions: filteredOptions,
          focusedOption: this._getNewFocusedOption(filteredOptions)
        }, this._bindCloseMenuIfClickedOutside);
      }
    }
  }, {
    key: 'filterOptions',
    value: function filterOptions(options, values) {
      var _this5 = this;

      if (!this.props.searchable) {
        return options;
      }

      var filterValue = this._optionsFilterString;
      var exclude = (values || this.state.values).map(function (i) {
        return i.value;
      });

      if (this.props.filterOptions) {
        return this.props.filterOptions.call(this, options, filterValue, exclude);
      } else {
        var filterOption = function filterOption(op) {
          if (_this5.props.multi && exclude.indexOf(op.value) > -1) {
            return false;
          }
          if (_this5.props.filterOption) {
            return _this5.props.filterOption.call(_this5, op, filterValue);
          }

          var valueTest = String(op.value),
              labelTest = String(op.label);

          return !filterValue || _this5.props.matchPos === 'start' ? _this5.props.matchProp !== 'label' && valueTest.toLowerCase().substr(0, filterValue.length) === filterValue || _this5.props.matchProp !== 'value' && labelTest.toLowerCase().substr(0, filterValue.length) === filterValue : _this5.props.matchProp !== 'label' && valueTest.toLowerCase().indexOf(filterValue.toLowerCase()) >= 0 || _this5.props.matchProp !== 'value' && labelTest.toLowerCase().indexOf(filterValue.toLowerCase()) >= 0;
        };

        return (options || []).filter(filterOption);
      }
    }
  }, {
    key: 'selectFocusedOption',
    value: function selectFocusedOption() {
      return this.selectValue(this.state.focusedOption);
    }
  }, {
    key: 'focusOption',
    value: function focusOption(op) {
      this.setState({
        focusedOption: op
      });
    }
  }, {
    key: 'focusNextOption',
    value: function focusNextOption() {
      this.focusAdjacentOption('next');
    }
  }, {
    key: 'focusPreviousOption',
    value: function focusPreviousOption() {
      this.focusAdjacentOption('previous');
    }
  }, {
    key: 'focusAdjacentOption',
    value: function focusAdjacentOption(dir) {
      this._focusedOptionReveal = true;

      var ops = this.state.filteredOptions;

      if (!this.state.isOpen) {
        this.setState({
          isOpen: true,
          inputValue: '',
          focusedOption: this.state.focusedOption || ops[dir === 'next' ? 0 : ops.length - 1]
        }, this._bindCloseMenuIfClickedOutside);
        return;
      }

      if (!ops.length) {
        return;
      }

      var focusedIndex = -1;

      for (var i = 0; i < ops.length; i += 1) {
        if (this.state.focusedOption === ops[i]) {
          focusedIndex = i;
          break;
        }
      }

      var focusedOption = ops[0];

      if (dir === 'next' && focusedIndex > -1 && focusedIndex < ops.length - 1) {
        focusedOption = ops[focusedIndex + 1];
      } else if (dir === 'previous') {
        if (focusedIndex > 0) {
          focusedOption = ops[focusedIndex - 1];
        } else {
          focusedOption = ops[ops.length - 1];
        }
      }

      this.setState({
        focusedOption: focusedOption
      });
    }
  }, {
    key: 'unfocusOption',
    value: function unfocusOption(op) {
      if (this.state.focusedOption === op) {
        this.setState({
          focusedOption: null
        });
      }
    }
  }, {
    key: 'buildMenu',
    value: function buildMenu() {
      var focusedValue = this.state.focusedOption ? this.state.focusedOption.value : null;

      if (this.state.filteredOptions.length > 0) {
        focusedValue = _lodash2.default.isNull(focusedValue) ? this.state.filteredOptions[0] : focusedValue;
      }

      var ops = Object.keys(this.state.filteredOptions).map(function (key) {
        var op = this.state.filteredOptions[key];
        var isFocused = focusedValue === op.value;

        var optionClass = (0, _classnames2.default)({
          'item': true,
          'is-focused': isFocused,
          'is-disabled': op.disabled
        });

        var ref = isFocused ? 'focused' : null;

        var mouseEnter = this.focusOption.bind(this, op);
        var mouseLeave = this.unfocusOption.bind(this, op);
        var mouseDown = this.selectValue.bind(this, op);

        if (op.disabled) {
          return _react2.default.createElement(
            'li',
            {
              ref: ref,
              key: Math.random(),
              className: optionClass
            },
            _react2.default.createElement(
              'a',
              { href: 'javascript:;' },
              op.label
            )
          );
        } else {
          return _react2.default.createElement(
            'li',
            {
              ref: ref,
              key: Math.random(),
              className: optionClass,
              onMouseEnter: mouseEnter,
              onMouseLeave: mouseLeave,
              onMouseDown: mouseDown,
              onClick: mouseDown
            },
            _react2.default.createElement(
              'a',
              { href: 'javascript:;' },
              op.label
            )
          );
        }
      }, this);

      return ops.length ? ops : _react2.default.createElement(
        'div',
        { className: 'select-noresults' },
        this.props.asyncOptions && !this.state.inputValue ? this.props.searchPromptText : this.props.noResultsText
      );
    }
  }, {
    key: 'handleOptionLabelClick',
    value: function handleOptionLabelClick(value, event) {
      var handler = this.props.onOptionLabelClick;

      if (handler) {
        handler(value, event);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var selectClass = (0, _classnames2.default)('dropdown', this.props.className, {
        'is-multi': this.props.multi,
        'is-searchable': this.props.searchable,
        'open': this.state.isOpen,
        'is-focused': this.state.isFocused,
        'is-loading': this.state.isLoading,
        'is-disabled': this.props.disabled,
        'has-value': this.state.value
      }),
          value = [];

      if (this.props.multi) {
        this.state.values.forEach(function (val) {
          var props = {
            optionLabelClick: Boolean(this.props.onOptionLabelClick),
            onOptionLabelClick: this.handleOptionLabelClick.bind(this, val),
            onRemove: this.removeValue.bind(this, val)
          };

          for (var key in val) {
            if (_lodash2.default.has(val, key)) {
              props[key] = val[key];
            }
          }

          value.push(_react2.default.createElement(Option, _extends({}, props, { key: Math.random() })));
        }, this);
      }

      if (!this.state.inputValue && (!this.props.multi || !value.length)) {
        value.push(_react2.default.createElement(
          'div',
          { className: 'select-placeholder', key: 'placeholder' },
          this.state.placeholder
        ));
      }

      var loading = this.state.isLoading ? _react2.default.createElement('span', { className: 'select-loading', 'aria-hidden': 'true' }) : null;

      var clear = this.props.multi && this.state.value && !this.props.disabled ? _react2.default.createElement('span', { className: 'select-clear',
        title: this.props.multi ? this.props.clearAllText : this.props.clearValueText,
        'aria-label': this.props.multi ? this.props.clearAllText : this.props.clearValueText, onMouseDown: this.clearValue,
        onClick: this.clearValue,
        dangerouslySetInnerHTML: { __html: '&times;' }
      }) : null;

      var menu;
      var menuProps;

      if (this.state.isOpen) {
        var pullRight = this.props.pullRight ? { 'dropdown-menu-right': this.props.pullRight } : null;

        menuProps = {
          ref: 'menu',
          className: (0, _classnames2.default)('dropdown-menu', pullRight)
        };

        if (this.props.multi) {
          menuProps.onMouseDown = this.handleMouseDown;
        }

        menu = _react2.default.createElement(
          'div',
          { className: 'select-menu-outer' },
          _react2.default.createElement(
            'ul',
            menuProps,
            _react2.default.createElement('span', { className: 'arrow' }),
            this.buildMenu()
          )
        );
      }

      var input;
      var inputProps = {
        ref: 'input',
        className: 'select-input',
        tabIndex: this.props.tabIndex || 0,
        onFocus: this.handleInputFocus,
        onBlur: this.handleInputBlur
      };

      for (var key in this.props.inputProps) {
        if (_lodash2.default.has(this.props.inputProps, key)) {
          inputProps[key] = this.props.inputProps[key];
        }
      }

      if (this.props.searchable && !this.props.disabled) {
        input = _react2.default.createElement(Input, _extends({ value: this.state.inputValue, onChange: this.handleInputChange, minWidth: '5px' }, inputProps));
      } else {
        if (!this.props.multi) {
          input = _react2.default.createElement(
            'div',
            inputProps,
            '\xA0'
          );
        }
      }

      return _react2.default.createElement(
        'div',
        { ref: 'wrapper', className: selectClass, style: this.props.style },
        _react2.default.createElement('input', { type: 'hidden', ref: 'value', name: this.props.name, value: this.state.value, disabled: this.props.disabled }),
        _react2.default.createElement(
          'div',
          { className: 'select-control', ref: 'control', onKeyDown: this.handleKeyDown, onMouseDown: this.handleMouseDown, onTouchEnd: this.handleMouseDown },
          value,
          input,
          _react2.default.createElement('span', { className: 'select-arrow icon icon-arrowdown' }),
          loading,
          clear
        ),
        menu
      );
    }
  }]);

  return Select;
}(_react2.default.Component);

exports.default = Select;


Select.defaultProps = {
  value: undefined,
  multi: false,
  disabled: false,
  options: undefined,
  delimiter: ',',
  asyncOptions: undefined,
  autoload: true,
  placeholder: 'Select...',
  noResultsText: 'No results found',
  clearable: true,
  clearValueText: 'Clear value',
  clearAllText: 'Clear all',
  searchable: true,
  searchPromptText: 'Type to search',
  name: undefined,
  onChange: undefined,
  className: undefined,
  matchPos: 'any',
  matchProp: 'any',
  inputProps: {}
};

Select.propTypes = {
  value: _propTypes2.default.any, // initial field value
  multi: _propTypes2.default.bool, // multi-value input
  disabled: _propTypes2.default.bool, // whether the Select is disabled or not
  options: _propTypes2.default.array, // array of options
  delimiter: _propTypes2.default.string, // delimiter to use to join multiple values
  asyncOptions: _propTypes2.default.func, // function to call to get options
  autoload: _propTypes2.default.bool, // whether to auto-load the default async options set
  placeholder: _propTypes2.default.string, // field placeholder, displayed when there's no value
  noResultsText: _propTypes2.default.string, // placeholder displayed when there are no matching search results
  clearable: _propTypes2.default.bool, // should it be possible to reset value
  clearValueText: _propTypes2.default.string, // title for the "clear" control
  clearAllText: _propTypes2.default.string, // title for the "clear" control when multi: true
  searchable: _propTypes2.default.bool, // whether to enable searching feature or not
  searchPromptText: _propTypes2.default.string, // label to prompt for search input
  name: _propTypes2.default.string, // field name, for hidden <input /> tag
  onChange: _propTypes2.default.func, // onChange handler: function(newValue) {}
  onFocus: _propTypes2.default.func, // onFocus handler: function(event) {}
  onBlur: _propTypes2.default.func, // onBlur handler: function(event) {}
  className: _propTypes2.default.string, // className for the outer element
  filterOption: _propTypes2.default.func, // method to filter a single option: function(option, filterString)
  filterOptions: _propTypes2.default.func, // method to filter the options array: function([options], filterString, [values])
  matchPos: _propTypes2.default.string, // (any|start) match the start or entire string when filtering
  matchProp: _propTypes2.default.string, // (any|label|value) which option property to filter on
  inputProps: _propTypes2.default.object // custom attributes for the Input (in the select-control) e.g: {'data-foo': 'bar'}
};
module.exports = exports['default'];